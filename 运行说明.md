# PBFT DID Chain 运行说明

## 一、系统配置信息

### 1.1 节点配置
- **最大容错节点数**: 1 (MaxFaultyNode = 1)
- **总节点数**: 4 (TotalNodeNO = 3*MaxFaultyNode + 1)
- **节点ID列表**: [0, 1, 2, 3]
- **端口规则**: `PortByID(id) = 30000 + id`
  - 节点0: 端口 30000
  - 节点1: 端口 30001
  - 节点2: 端口 30002
  - 节点3: 端口 30003

### 1.2 网络协议
- **节点间通信**: TCP (用于共识消息)
- **客户端请求**: UDP (用于接收客户端请求)
- **客户端回复**: UDP (端口 8088)

---

## 二、启动节点

### 2.1 启动步骤

**需要启动4个节点才能正常运行PBFT共识！**

#### 方法一：使用编译好的可执行文件

打开4个终端窗口，分别执行：

```bash
# 终端1 - 启动节点0 (主节点)
.\pbftdidchain.exe 0

# 终端2 - 启动节点1
.\pbftdidchain.exe 1

# 终端3 - 启动节点2
.\pbftdidchain.exe 2

# 终端4 - 启动节点3
.\pbftdidchain.exe 3
```

#### 方法二：使用Go命令运行

```bash
# 终端1
go run main.go 0

# 终端2
go run main.go 1

# 终端3
go run main.go 2

# 终端4
go run main.go 3
```

### 2.2 节点启动后的状态

节点启动后会：

1. **初始化共识引擎** (`consensus.StateEngine`)
   - 确定主节点（Primary）：`PrimaryID = CurViewID % TotalNodeNO`
   - 节点0通常是第一个主节点

2. **启动服务监听** (`service.WaitRequest`)
   - 在UDP端口 `30000 + id` 上监听客户端请求
   - 例如：节点1监听端口 30001

3. **启动P2P网络** (`p2pnetwork`)
   - 在TCP端口 `30000 + id` 上监听其他节点的连接
   - 主动连接其他节点（节点列表：[0,1,2,3]）

4. **启动消息分发器** (`node.Dispatch`)
   - 处理来自服务层的客户端请求
   - 处理来自共识层的已提交请求
   - 处理直接回复消息

5. **启动共识引擎** (`consensus.StartConsensus`)
   - 处理PBFT协议消息（PrePrepare, Prepare, Commit等）
   - 处理视图变更消息（ViewChange, NewView等）

### 2.3 启动成功的标志

节点启动成功后会看到类似输出：

```
===>PBFT Demo PID:xxxxx

==============================================>
*                                             *
*     Practical Byzantine Fault Tolerance     *
*                                             *
<==============================================

Consensus node[0] start primary[true]......
===>Service Listening at[30000]
===>P2p node is waiting at:0.0.0.0:30000
node [1] connected=[...]
node [2] connected=[...]
node [3] connected=[...]
```

---

## 三、发送客户端请求

### 3.1 使用测试客户端

项目提供了测试客户端 `test/client.go`，可以发送请求到节点。

#### 编译客户端

```bash
cd test
go build -o client.exe client.go
```

#### 运行客户端

```bash
# 客户端需要指定主节点ID（通常是0）
.\client.exe 0
```

客户端会：
1. 向主节点（节点0，端口30000）发送UDP请求
2. 在端口8088上监听回复
3. 等待收到至少2个节点的回复后，认为共识成功

### 3.2 客户端请求格式

客户端发送的请求结构：

```json
{
  "timestamp": 1234567890,
  "clientID": "Client's address",
  "operation": "<READ TX FROM POOL>"
}
```

### 3.3 请求处理流程

1. **客户端** → 发送Request到主节点的UDP端口
2. **主节点** → 接收请求，创建PrePrepare消息，广播给所有备份节点
3. **备份节点** → 验证PrePrepare，发送Prepare消息
4. **所有节点** → 收集足够的Prepare消息后，发送Commit消息
5. **所有节点** → 收集足够的Commit消息后，执行操作并发送Reply给客户端
6. **客户端** → 收到至少2f+1个Reply后，认为共识成功

---

## 四、模块依赖关系

```
main.go (入口)
  └── node/
       ├── consensus/ (PBFT共识引擎)
       │    ├── p2pnetwork/ (节点间TCP通信)
       │    └── message/ (消息定义)
       │
       ├── service/ (业务服务层)
       │    └── message/ (消息定义)
       │
       └── message/ (消息定义)
```

### 4.1 模块说明

- **node**: 节点核心，协调共识和服务层
- **consensus**: PBFT共识协议实现
- **service**: 业务逻辑层，处理客户端请求
- **p2pnetwork**: P2P网络层，节点间TCP通信
- **message**: 消息定义，包括Request、Reply、PrePrepare等

---

## 五、常见问题

### 5.1 节点无法连接

**问题**: 节点启动时显示 "node [X] is not valid currently"

**解决**: 
- 确保所有4个节点都已启动
- 检查端口是否被占用（30000-30003）
- 检查防火墙设置

### 5.2 客户端收不到回复

**问题**: 客户端发送请求后没有收到回复

**解决**:
- 确保至少3个节点正常运行（容错1个）
- 检查主节点是否正常运行
- 查看节点日志，确认请求是否被接收

### 5.3 端口冲突

**问题**: 启动节点时提示端口被占用

**解决**:
```bash
# Windows查看端口占用
netstat -ano | findstr :30000

# 结束占用进程（替换PID）
taskkill /PID <进程ID> /F
```

---

## 六、完整运行示例

### 步骤1：启动4个节点

```bash
# 终端1
.\pbftdidchain.exe 0

# 终端2
.\pbftdidchain.exe 1

# 终端3
.\pbftdidchain.exe 2

# 终端4
.\pbftdidchain.exe 3
```

### 步骤2：等待所有节点连接成功

确保看到所有节点都显示连接成功的信息。

### 步骤3：运行客户端测试

```bash
# 新终端
cd test
go run client.go 0
```

### 步骤4：观察输出

- **节点终端**: 会显示接收到的请求和共识消息
- **客户端终端**: 会显示 "Consensus(seq=X) operation(1) success!"

---

## 七、停止节点

按 `Ctrl+C` 可以优雅地停止节点，节点会输出：

```
Finish by signal:===>[interrupt]
Node[X] exit because of:...
```

---

## 八、注意事项

1. **必须启动4个节点**: PBFT需要至少4个节点（容错1个）
2. **节点ID必须连续**: 建议使用0,1,2,3，系统配置的节点列表是[0,1,2,3]
3. **端口不能冲突**: 确保30000-30003端口可用
4. **主节点选择**: 主节点ID = ViewID % 4，初始ViewID通常为0，所以节点0是第一个主节点
5. **客户端端口**: 客户端监听8088端口，确保该端口可用

